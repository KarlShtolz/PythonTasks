"""
Для того чтобы компьютеры поддерживали актуальное время, они могут обращаться к серверам точного времени SNTP
 (Simple Network Time Protocol). К сожалению, компьютер не может просто получить время у сервера, потому что информация
 по сети передаётся не мгновенно: пока сообщение с текущим временем дойдёт до компьютера, оно потеряет свою
 актуальность. Протокол взаимодействия клиента (компьютера, запрашивающего точное время) и сервера (компьютера,
 выдающего точное время) выглядит следующим образом:

1. Клиент отправляет запрос на сервер и запоминает время отправления A (по клиентскому времени).

2. Сервер получает запрос в момент времени B (по точному серверному времени) и отправляет клиенту сообщение, содержащее
 время B.

3. Клиент получает ответ на свой запрос в момент времени C (по клиентскому времени) и запоминает его. Теперь клиент, из
предположения, что сетевые задержки при передаче сообщений от клиента серверу и от сервера клиенту одинаковы, может
определить и установить себе точное время, используя известные значения A, B, C.

Вам предстоит реализовать алгоритм, с точностью до секунды определяющий точное время для установки на клиенте по
известным A, B и C. При необходимости округлите результат до целого числа секунд по правилам арифметики (в меньшую
сторону, если дробная часть числа меньше 1/2, иначе в большую сторону).

Возможно, что, пока клиент ожидал ответа, по клиентскому времени успели наступить новые сутки, однако известно, что
между отправкой клиентом запроса и получением ответа от сервера прошло менее 24 часов.
INPUT:
23:01:01
15:01:01
02:01:01
OUTPUT:
16:31:01

INPUT:
15:01:00
18:09:45
15:01:40

OUTPUT:
18:10:05
"""

import math
a = input()
b = input()
c = input()
la = a.split(":")
lb = b.split(":")
lc = c.split(":")
t_start = (3600 * int(la[0])) + (60 * int(la[1])) + int(la[2])
t_end = (3600 * int(lc[0])) + (60 * int(lc[1])) + int(lc[2])
if t_start > t_end:
    differ = 86400 - t_start + t_end
else:
    differ = t_end - t_start
if differ % 2 == 0:
    half_dif = differ / 2
else:
    if (differ * 10) // 10 < 5:
        half_dif = math.floor(differ / 2)
    else:
        half_dif = math.ceil(differ / 2)
tmp = [int(lb[0]), int(lb[1]), int(lb[2])]
tmp[0] += (half_dif // 3600)
tmp[1] += ((half_dif % 3600) // 60)
tmp[2] += ((half_dif % 3600) % 60)
if tmp[2] > 59:
    tmp[1] += tmp[2] // 60
    tmp[2] = tmp[2] % 60
if tmp[1] > 59:
    tmp[0] += tmp[1] // 60
    tmp[1] = tmp[1] % 60
if tmp[0] > 23:
    tmp[0] = tmp[0] % 24
a = int(tmp[0])
b = int(tmp[1])
c = int(tmp[2])
str_h = ""
str_m = ""
str_s = ""
if a == 0:
    str_h = "00"
elif 0 < a < 10:
    str_h = "0" + str(a)
else:
    str_h = str(a)
if b == 0:
    str_m = "00"
elif 0 < b < 10:
    str_m = "0" + str(b)
else:
    str_m = str(b)
if c == 0:
    str_s = "00"
elif 0 < c < 10:
    str_s = "0" + str(c)
else:
    str_s = str(c)
print(str_h, str_m, str_s, sep=":")

